using System;
using System.Drawing;
using System.Runtime.InteropServices;

namespace WinApi.User32
{
    public class User32
    {
        const string libraryName = "User32.dll";

        /// <summary>
        /// Извлекает дескриптор в окно верхнего уровня, имя класса и имя окна которого соответствуют указанным строкам.
        /// Эта функция не выполняет поиск дочерних окон. Эта функция не выполняет поиск с учетом регистра.
        /// Для поиска дочерних окон, начиная с указанного дочернего окна, используйте функцию FindWindowEx .
        /// </summary>
        /// <param name="className">Имя класса или атом класса, созданный при предыдущем вызове функции
        /// RegisterClass или RegisterClassEx. Атом должен быть в нижнем порядке слово lpClassName;
        /// Слово высокого порядка должно быть равно нулю.
        /// Если lpClassName указывает на строку, она указывает имя класса окна. Имя класса может быть любым именем,
        /// зарегистрированным с помощью RegisterClass или RegisterClassEx, или любым из предопределенных
        /// имен классов элементов управления.Если lpClassName имеет значение NULL, оно находит любое окно,
        /// заголовок которого соответствует параметру lpWindowName .</param>
        /// <param name="windowName">Имя окна (заголовок окна). Если этот параметр имеет значение NULL, все имена окон совпадают.</param>
        /// <returns>Если функция выполняется успешно, возвращаемое значение представляет собой дескриптор для окна
        /// с указанным именем класса и именем окна.Если функция завершается сбоем, возвращается значение NULL.
        /// Эта функция не изменяет значение последней ошибки.</returns>
        [DllImport(libraryName, CharSet = CharSet.Ansi)]
        public static extern IntPtr FindWindowA(string className, string windowName);

        /// <summary>
        /// Извлекает дескриптор для окна верхнего уровня, имя класса и имя окна которого соответствуют указанным строкам.
        /// Эта функция не выполняет поиск дочерних окон. Эта функция не выполняет поиск с учетом регистра.
        /// Для поиска дочерних окон, начиная с указанного дочернего окна, используйте функцию FindWindowEx .
        /// </summary>
        /// <param name="className">Имя класса или атом класса, созданный предыдущим вызовом функции
        /// RegisterClass или RegisterClassEx . Атом должен быть в нижнем порядке в слове lpClassName;
        /// Слово высокого порядка должно быть равно нулю. Если lpClassName указывает на строку,
        /// она указывает имя класса окна. Имя класса может быть любым именем, зарегистрированным
        /// в RegisterClass или RegisterClassEx, или любым из предопределенных имен класса элементов управления.
        /// Если lpClassName имеет значение NULL, он находит любое окно, заголовок которого
        /// соответствует параметру lpWindowName .</param>
        /// <param name="windowName">Имя окна (название окна). Если этот параметр имеет значение NULL,
        /// все имена окон совпадают.</param>
        /// <returns>Если функция выполняется успешно, возвращаемое значение представляет собой дескриптор
        /// окна с указанным именем класса и именем окна. Если функция завершается сбоем, возвращается значение NULL.
        /// Эта функция не изменяет значение последней ошибки.</returns>
        [DllImport(libraryName, CharSet = CharSet.Unicode)]
        public static extern IntPtr FindWindowW(string className, string windowName);

        /// <summary>
        /// Положение курсора всегда указывается в координатах экрана и не зависит
        /// от режима отображения окна, содержащего курсор.
        /// Вызывающий процесс должен иметь WINSTA_READATTRIBUTES доступ к оконной станции.
        /// Рабочий стол для ввода должен быть текущим рабочим столом при вызове GetCursorPos.
        /// Вызовите OpenInputDesktop, чтобы определить, является ли текущий рабочий
        /// стол рабочим столом ввода. Если это не так, вызовите SetThreadDesktop с HDESK,
        /// возвращаемым OpenInputDesktop, чтобы переключиться на этот рабочий стол.
        /// </summary>
        /// <param name="lpPoint">Указатель на структуру System.Drawing.Point</param>
        /// <returns>Возвращает ненулевое значение в случае успеха или ноль
        /// в противном случае. Чтобы получить расширенную информацию об ошибке,
        /// вызовите GetLastError.</returns>
        [DllImport(libraryName, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetCursorPos(out Point lpPoint);

        /// <summary>
        /// Перемещает курсор в указанные координаты экрана. Если новые координаты
        /// находятся за пределами прямоугольника экрана, установленного последним
        /// вызовом функции ClipCursor, система автоматически корректирует координаты
        /// таким образом, чтобы курсор оставался внутри прямоугольника.
        /// </summary>
        /// <param name="x">Новая координата x курсора в экранных координатах.</param>
        /// <param name="y">Новая координата y курсора в экранных координатах.</param>
        /// <returns>Возвращает ненулевое значение в случае успеха или ноль в
        /// противном случае. Чтобы получить расширенную информацию об ошибке,
        /// вызовите GetLastError.</returns>
        [DllImport(libraryName, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetCursorPos(int x, int y);

        /// <summary>
        /// Переносит поток, создавший указанное окно, на передний план и активирует окно.
        /// Ввод с помощью клавиатуры направляется в окно, и для пользователя изменяются различные визуальные подсказки.
        /// Система назначает потоку, создавщему окно переднего плана, немного более высокий приоритет, чем другим потокам.
        /// Информация по ньюанасам. https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-setforegroundwindow#remarks
        /// </summary>
        /// <param name="hWnd">Дескриптор окна, которое должно быть активировано и выведено на передний план.</param>
        /// <returns>Если окно было выведено на передний план, возвращаемое значение не равно нулю.
        /// Если окно не было выведено на передний план, возвращаемое значение равно нулю.</returns>
        [DllImport(libraryName)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetForegroundWindow(IntPtr hWnd);

        /// <summary>
        /// Изменяет размер, положение и порядок Z дочернего, всплывающего окна или окна верхнего уровня.
        /// Эти окна упорядочены в соответствии с их внешним видом на экране.
        /// Самое верхнее окно получает наивысший ранг и является первым окном в порядке Z.
        /// </summary>
        /// <param name="hWnd">Дескриптор окна.</param>
        /// <param name="hWndAfter">Дескриптор окна перед расположенным окном в порядке Z.
        /// Этот параметр должен быть дескриптором окна или одним из следующих значений.</param>
        /// <param name="x">Новое положение левой части окна в клиентских координатах.</param>
        /// <param name="y">Новое положение верхней части окна в клиентских координатах.</param>
        /// <param name="cx">Новая ширина окна (в пикселях).</param>
        /// <param name="cy">Новая высота окна (в пикселях).</param>
        /// <param name="flags">Флаги определения размера и расположения окна.
        /// Этот параметр может быть сочетанием следующих значений.
        /// https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-setwindowpos#parameters</param>
        /// <returns>Если функция выполняется успешно, возвращается ненулевое значение.
        /// Если функция выполняется неудачно, возвращается нулевое значение.
        /// Дополнительные сведения об ошибке можно получить, вызвав GetLastError.</returns>
        [DllImport(libraryName, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndAfter, int x, int y, int cx, int cy, uint flags);
    }
}