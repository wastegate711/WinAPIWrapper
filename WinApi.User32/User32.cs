using System;
using System.Drawing;
using System.Runtime.InteropServices;

namespace WinApi.User32
{
    public class User32
    {
        const string libraryName = "User32.dll";

        /// <summary>
        /// Извлекает дескриптор в окно верхнего уровня, имя класса и имя окна которого соответствуют указанным строкам.
        /// Эта функция не выполняет поиск дочерних окон. Эта функция не выполняет поиск с учетом регистра.
        /// Для поиска дочерних окон, начиная с указанного дочернего окна, используйте функцию FindWindowEx .
        /// </summary>
        /// <param name="className">Имя класса или атом класса, созданный при предыдущем вызове функции
        /// RegisterClass или RegisterClassEx. Атом должен быть в нижнем порядке слово lpClassName;
        /// Слово высокого порядка должно быть равно нулю.
        /// Если lpClassName указывает на строку, она указывает имя класса окна. Имя класса может быть любым именем,
        /// зарегистрированным с помощью RegisterClass или RegisterClassEx, или любым из предопределенных
        /// имен классов элементов управления.Если lpClassName имеет значение NULL, оно находит любое окно,
        /// заголовок которого соответствует параметру lpWindowName .</param>
        /// <param name="windowName">Имя окна (заголовок окна). Если этот параметр имеет значение NULL, все имена окон совпадают.</param>
        /// <returns>Если функция выполняется успешно, возвращаемое значение представляет собой дескриптор для окна
        /// с указанным именем класса и именем окна.Если функция завершается сбоем, возвращается значение NULL.
        /// Эта функция не изменяет значение последней ошибки.</returns>
        [DllImport(libraryName, CharSet = CharSet.Ansi)]
        public static extern IntPtr FindWindowA(string className, string windowName);

        /// <summary>
        /// Извлекает дескриптор для окна верхнего уровня, имя класса и имя окна которого соответствуют указанным строкам.
        /// Эта функция не выполняет поиск дочерних окон. Эта функция не выполняет поиск с учетом регистра.
        /// Для поиска дочерних окон, начиная с указанного дочернего окна, используйте функцию FindWindowEx .
        /// </summary>
        /// <param name="className">Имя класса или атом класса, созданный предыдущим вызовом функции
        /// RegisterClass или RegisterClassEx . Атом должен быть в нижнем порядке в слове lpClassName;
        /// Слово высокого порядка должно быть равно нулю. Если lpClassName указывает на строку,
        /// она указывает имя класса окна. Имя класса может быть любым именем, зарегистрированным
        /// в RegisterClass или RegisterClassEx, или любым из предопределенных имен класса элементов управления.
        /// Если lpClassName имеет значение NULL, он находит любое окно, заголовок которого
        /// соответствует параметру lpWindowName .</param>
        /// <param name="windowName">Имя окна (название окна). Если этот параметр имеет значение NULL,
        /// все имена окон совпадают.</param>
        /// <returns>Если функция выполняется успешно, возвращаемое значение представляет собой дескриптор
        /// окна с указанным именем класса и именем окна. Если функция завершается сбоем, возвращается значение NULL.
        /// Эта функция не изменяет значение последней ошибки.</returns>
        [DllImport(libraryName, CharSet = CharSet.Unicode)]
        public static extern IntPtr FindWindowW(string className, string windowName);

        /// <summary>
        /// Положение курсора всегда указывается в координатах экрана и не зависит
        /// от режима отображения окна, содержащего курсор.
        /// Вызывающий процесс должен иметь WINSTA_READATTRIBUTES доступ к оконной станции.
        /// Рабочий стол для ввода должен быть текущим рабочим столом при вызове GetCursorPos.
        /// Вызовите OpenInputDesktop, чтобы определить, является ли текущий рабочий
        /// стол рабочим столом ввода. Если это не так, вызовите SetThreadDesktop с HDESK,
        /// возвращаемым OpenInputDesktop, чтобы переключиться на этот рабочий стол.
        /// </summary>
        /// <param name="lpPoint">Указатель на структуру System.Drawing.Point</param>
        /// <returns>Возвращает ненулевое значение в случае успеха или ноль
        /// в противном случае. Чтобы получить расширенную информацию об ошибке,
        /// вызовите GetLastError.</returns>
        [DllImport(libraryName, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetCursorPos(out Point lpPoint);

        /// <summary>
        /// Перемещает курсор в указанные координаты экрана. Если новые координаты
        /// находятся за пределами прямоугольника экрана, установленного последним
        /// вызовом функции ClipCursor, система автоматически корректирует координаты
        /// таким образом, чтобы курсор оставался внутри прямоугольника.
        /// </summary>
        /// <param name="x">Новая координата x курсора в экранных координатах.</param>
        /// <param name="y">Новая координата y курсора в экранных координатах.</param>
        /// <returns>Возвращает ненулевое значение в случае успеха или ноль в
        /// противном случае. Чтобы получить расширенную информацию об ошибке,
        /// вызовите GetLastError.</returns>
        [DllImport(libraryName, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetCursorPos(int x, int y);
    }
}